// Copyright 2025 The Etc2 Authors.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0>. This file may not be copied,
// modified, or distributed except according to those terms.
//
// SPDX-License-Identifier: Apache-2.0

package etc2

import (
	"image"
	"io"
)

// Decode decodes the ETC-compressed image in src into dst, given the image
// dimensions as measured in 4Ã—4 pixel blocks.
//
// dst should be the result of calling f.NewImage.
func (f Format) Decode(dst image.Image, src io.Reader, widthInBlocks int, heightInBlocks int) error {
	if (dst == nil) || (src == nil) ||
		(widthInBlocks < 0) || (widthInBlocks > 16384) ||
		(heightInBlocks < 0) || (heightInBlocks > 16384) {
		return ErrBadArgument
	} else if b := dst.Bounds(); (b.Dx() < (widthInBlocks * 4)) || (b.Dy() < (heightInBlocks * 4)) {
		return ErrBadArgument
	}

	dstPix, dstStride := []byte(nil), 0
	switch f {
	case FormatETC1S,
		FormatETC1,
		FormatETC2RGB,
		FormatETC2SRGB:
		if m, ok := dst.(*image.RGBA); !ok {
			return ErrBadImageType
		} else {
			dstPix, dstStride = m.Pix, m.Stride
		}
		f = FormatETC1

	case FormatETC2RGBA1,
		FormatETC2SRGBA1:
		if m, ok := dst.(*image.RGBA); !ok {
			return ErrBadImageType
		} else {
			dstPix, dstStride = m.Pix, m.Stride
		}
		f = FormatETC2RGBA1

	case FormatETC2RGBA,
		FormatETC2SRGBA:
		if m, ok := dst.(*image.NRGBA); !ok {
			return ErrBadImageType
		} else {
			dstPix, dstStride = m.Pix, m.Stride
		}
		f = FormatETC2RGBA

	case FormatETC2UnsignedR11,
		FormatETC2SignedR11:
		if m, ok := dst.(*image.Gray16); !ok {
			return ErrBadImageType
		} else {
			dstPix, dstStride = m.Pix, m.Stride
		}

	case FormatETC2UnsignedRG11,
		FormatETC2SignedRG11:
		if m, ok := dst.(*image.RGBA64); !ok {
			return ErrBadImageType
		} else {
			dstPix, dstStride = m.Pix, m.Stride
		}

	default:
		return ErrBadArgument
	}

	numBytesRemaining := int64(widthInBlocks*heightInBlocks) * int64(f.BytesPerBlock())
	const decoderBufferSize = 4096
	buf, bufI := &[decoderBufferSize]byte{}, decoderBufferSize
	work := [64]byte{}

	for by := 0; by < heightInBlocks; by++ {
		rowPix := dstPix[4*by*dstStride:]

		for bx := 0; bx < widthInBlocks; bx++ {
			if bufI >= decoderBufferSize {
				n := int(min(numBytesRemaining, decoderBufferSize))
				if _, err := io.ReadFull(src, buf[decoderBufferSize-n:]); err != nil {
					return err
				}
				bufI = decoderBufferSize - n
				numBytesRemaining -= int64(n)
			}

			switch f {
			case FormatETC1, FormatETC2RGBA1:
				colorCode := readU64BE(buf[bufI+0:])
				bufI += 8
				decodeColor(&work, colorCode, f != FormatETC1)
				copy(rowPix[0*dstStride:], work[0x00:0x10])
				copy(rowPix[1*dstStride:], work[0x10:0x20])
				copy(rowPix[2*dstStride:], work[0x20:0x30])
				copy(rowPix[3*dstStride:], work[0x30:0x40])
				rowPix = rowPix[16:]

			case FormatETC2RGBA:
				alphaCode := readU64BE(buf[bufI+0:])
				colorCode := readU64BE(buf[bufI+8:])
				bufI += 16
				decodeColor(&work, colorCode, false)
				decodeAlpha(&work, alphaCode)
				copy(rowPix[0*dstStride:], work[0x00:0x10])
				copy(rowPix[1*dstStride:], work[0x10:0x20])
				copy(rowPix[2*dstStride:], work[0x20:0x30])
				copy(rowPix[3*dstStride:], work[0x30:0x40])
				rowPix = rowPix[16:]

			case FormatETC2UnsignedR11:
				rCode := readU64BE(buf[bufI+0:])
				bufI += 8
				decode11u(&work, 0x00, rCode)
				copy(rowPix[0*dstStride:], work[0x00:0x08])
				copy(rowPix[1*dstStride:], work[0x08:0x10])
				copy(rowPix[2*dstStride:], work[0x10:0x18])
				copy(rowPix[3*dstStride:], work[0x18:0x20])
				rowPix = rowPix[8:]

			case FormatETC2SignedR11:
				rCode := readU64BE(buf[bufI+0:])
				bufI += 8
				decode11s(&work, 0x00, rCode)
				copy(rowPix[0*dstStride:], work[0x00:0x08])
				copy(rowPix[1*dstStride:], work[0x08:0x10])
				copy(rowPix[2*dstStride:], work[0x10:0x18])
				copy(rowPix[3*dstStride:], work[0x18:0x20])
				rowPix = rowPix[8:]

			case FormatETC2UnsignedRG11:
				rCode := readU64BE(buf[bufI+0:])
				gCode := readU64BE(buf[bufI+8:])
				bufI += 16
				decode11u(&work, 0x00, rCode)
				decode11u(&work, 0x20, gCode)
				weaveRG11(rowPix, dstStride, &work)
				rowPix = rowPix[32:]

			case FormatETC2SignedRG11:
				rCode := readU64BE(buf[bufI+0:])
				gCode := readU64BE(buf[bufI+8:])
				bufI += 16
				decode11s(&work, 0x00, rCode)
				decode11s(&work, 0x20, gCode)
				weaveRG11(rowPix, dstStride, &work)
				rowPix = rowPix[32:]
			}
		}
	}

	return nil
}

func readU64BE(buf []byte) uint64 {
	buf = buf[:8]
	return (uint64(buf[0]) << 56) |
		(uint64(buf[1]) << 48) |
		(uint64(buf[2]) << 40) |
		(uint64(buf[3]) << 32) |
		(uint64(buf[4]) << 24) |
		(uint64(buf[5]) << 16) |
		(uint64(buf[6]) << 8) |
		(uint64(buf[7]))
}

func decodeColor(work *[64]byte, code uint64, oneBitAlpha bool) {
	r0 := uint32(0)
	r1 := uint32(0)
	g0 := uint32(0)
	g1 := uint32(0)
	b0 := uint32(0)
	b1 := uint32(0)

	flip := (code & 0x1_0000_0000) != 0
	diff := (code & 0x2_0000_0000) != 0
	tran := oneBitAlpha && !diff

	if oneBitAlpha || diff {
		r0 = (0x1F & uint32(code>>0x3B))
		r1 = r0 + diffs[7&(code>>0x38)]
		if (r1 >> 5) != 0 {
			decodeT(work, code, tran)
			return
		}
		r0 = (r0 << 3) | (r0 >> 2)
		r1 = (r1 << 3) | (r1 >> 2)

		g0 = (0x1F & uint32(code>>0x33))
		g1 = g0 + diffs[7&(code>>0x30)]
		if (g1 >> 5) != 0 {
			decodeH(work, code, tran)
			return
		}
		g0 = (g0 << 3) | (g0 >> 2)
		g1 = (g1 << 3) | (g1 >> 2)

		b0 = (0x1F & uint32(code>>0x2B))
		b1 = b0 + diffs[7&(code>>0x28)]
		if (b1 >> 5) != 0 {
			decodePlanar(work, code)
			return
		}
		b0 = (b0 << 3) | (b0 >> 2)
		b1 = (b1 << 3) | (b1 >> 2)

	} else {
		r0 = (0x0F & uint32(code>>0x3C))
		r0 = (r0 << 4) | r0
		r1 = (0x0F & uint32(code>>0x38))
		r1 = (r1 << 4) | r1

		g0 = (0x0F & uint32(code>>0x34))
		g0 = (g0 << 4) | g0
		g1 = (0x0F & uint32(code>>0x30))
		g1 = (g1 << 4) | g1

		b0 = (0x0F & uint32(code>>0x2C))
		b0 = (b0 << 4) | b0
		b1 = (0x0F & uint32(code>>0x28))
		b1 = (b1 << 4) | b1
	}

	decodeColorHalf(work, uint32(code),
		uint32(((code >> 0x25) & 7)),
		r0, g0, b0, flip, tran, false)
	decodeColorHalf(work, uint32(code),
		uint32(((code >> 0x22) & 7)),
		r1, g1, b1, flip, tran, true)
}

func decodeColorHalf(work *[64]byte, code uint32, which uint32, r uint32, g uint32, b uint32, flip bool, tran bool, second bool) {
	tranIndex := uint32(0xFFFF_FFFF)
	if tran {
		tranIndex = 2
		which |= 8
	}
	ms := &modifiers[which]

	x0, y0 := 0, 0
	if !second {
		// No-op.
	} else if flip {
		y0 = 2
	} else {
		x0 = 2
	}

	for i := range 8 {
		x, y := 0, 0
		if flip {
			x = (x0 + (i / 2)) & 3
			y = (y0 + (i & 1))
		} else {
			x = (x0 + (i / 4))
			y = (y0 + i) & 3
		}

		offset := (x * 4) | (y * 16)
		x4y := (x * 4) | y
		index := ((code >> x4y) & 1) |
			((code >> (x4y + 15)) & 2)

		if index == tranIndex {
			work[offset+0] = 0x00
			work[offset+1] = 0x00
			work[offset+2] = 0x00
			work[offset+3] = 0x00

		} else {
			m := ms[index]
			work[offset+0] = clamp[(r+m)&1023]
			work[offset+1] = clamp[(g+m)&1023]
			work[offset+2] = clamp[(b+m)&1023]
			work[offset+3] = 0xFF
		}
	}
}

func decodeT(work *[64]byte, code uint64, tran bool) {
	r := [4]uint8{}
	g := [4]uint8{}
	b := [4]uint8{}
	a := [4]uint8{}

	r[0] = (0x0C & uint8(code>>0x39)) |
		(0x03 & uint8(code>>0x38))
	r[0] = (r[0] << 4) | r[0]
	g[0] = (0x0F & uint8(code>>0x34))
	g[0] = (g[0] << 4) | g[0]
	b[0] = (0x0F & uint8(code>>0x30))
	b[0] = (b[0] << 4) | b[0]
	a[0] = 0xFF

	r[2] = (0x0F & uint8(code>>0x2C))
	r[2] = (r[2] << 4) | r[2]
	g[2] = (0x0F & uint8(code>>0x28))
	g[2] = (g[2] << 4) | g[2]
	b[2] = (0x0F & uint8(code>>0x24))
	b[2] = (b[2] << 4) | b[2]
	a[2] = 0xFF

	which := (0x06 & uint32(code>>0x21)) |
		(0x01 & uint32(code>>0x20))
	delta := uint32(thModifiers[which])

	r[1] = clamp[(uint32(r[2])+delta)&1023]
	g[1] = clamp[(uint32(g[2])+delta)&1023]
	b[1] = clamp[(uint32(b[2])+delta)&1023]
	a[1] = 0xFF

	r[3] = clamp[(uint32(r[2])-delta)&1023]
	g[3] = clamp[(uint32(g[2])-delta)&1023]
	b[3] = clamp[(uint32(b[2])-delta)&1023]
	a[3] = 0xFF

	if tran {
		r[2] = 0x00
		g[2] = 0x00
		b[2] = 0x00
		a[2] = 0x00
	}

	for i := range 16 {
		x := uint32(i & 3)
		y := uint32(i >> 2)

		x4y := (x * 4) | y
		index := (uint32(code>>x4y) & 1) |
			(uint32(code>>(x4y+15)) & 2)

		offset := i * 4
		work[offset+0] = r[index]
		work[offset+1] = g[index]
		work[offset+2] = b[index]
		work[offset+3] = a[index]
	}
}

func decodeH(work *[64]byte, code uint64, tran bool) {
	r := [4]uint8{}
	g := [4]uint8{}
	b := [4]uint8{}
	a := [4]uint8{}

	r[0] = (0x0F & uint8(code>>0x3B))
	r[0] = (r[0] << 4) | r[0]
	g[0] = (0x0E & uint8(code>>0x37)) |
		(0x01 & uint8(code>>0x34))
	g[0] = (g[0] << 4) | g[0]
	b[0] = (0x08 & uint8(code>>0x30)) |
		(0x07 & uint8(code>>0x2F))
	b[0] = (b[0] << 4) | b[0]

	r[2] = (0x0F & uint8(code>>0x2B))
	r[2] = (r[2] << 4) | r[2]
	g[2] = (0x0F & uint8(code>>0x27))
	g[2] = (g[2] << 4) | g[2]
	b[2] = (0x0F & uint8(code>>0x23))
	b[2] = (b[2] << 4) | b[2]

	rgb0 := (uint32(r[0]) << 0x10) |
		(uint32(g[0]) << 0x08) |
		(uint32(b[0]) << 0x00)
	rgb2 := (uint32(r[2]) << 0x10) |
		(uint32(g[2]) << 0x08) |
		(uint32(b[2]) << 0x00)
	which := (0x04 & uint32(code>>0x20)) |
		(0x02 & uint32(code>>0x1F))
	if rgb0 >= rgb2 {
		which |= 1
	}
	delta := uint32(thModifiers[which])

	r[1] = clamp[(uint32(r[0])-delta)&1023]
	g[1] = clamp[(uint32(g[0])-delta)&1023]
	b[1] = clamp[(uint32(b[0])-delta)&1023]
	a[1] = 0xFF

	r[0] = clamp[(uint32(r[0])+delta)&1023]
	g[0] = clamp[(uint32(g[0])+delta)&1023]
	b[0] = clamp[(uint32(b[0])+delta)&1023]
	a[0] = 0xFF

	r[3] = clamp[(uint32(r[2])-delta)&1023]
	g[3] = clamp[(uint32(g[2])-delta)&1023]
	b[3] = clamp[(uint32(b[2])-delta)&1023]
	a[3] = 0xFF

	r[2] = clamp[(uint32(r[2])+delta)&1023]
	g[2] = clamp[(uint32(g[2])+delta)&1023]
	b[2] = clamp[(uint32(b[2])+delta)&1023]
	a[2] = 0xFF

	if tran {
		r[2] = 0x00
		g[2] = 0x00
		b[2] = 0x00
		a[2] = 0x00
	}

	for i := range 16 {
		x := uint32(i & 3)
		y := uint32(i >> 2)

		x4y := (x * 4) | y
		index := (uint32(code>>x4y) & 1) |
			(uint32(code>>(x4y+15)) & 2)

		offset := i * 4
		work[offset+0] = r[index]
		work[offset+1] = g[index]
		work[offset+2] = b[index]
		work[offset+3] = a[index]
	}
}

func decodePlanar(work *[64]byte, code uint64) {
	r0 := (0x3F & uint32(code>>0x39))
	r0 = (r0 << 2) | (r0 >> 4)
	g0 := (0x40 & uint32(code>>0x32)) |
		(0x3F & uint32(code>>0x31))
	g0 = (g0 << 1) | (g0 >> 6)
	b0 := (0x20 & uint32(code>>0x2B)) |
		(0x18 & uint32(code>>0x28)) |
		(0x07 & uint32(code>>0x27))
	b0 = (b0 << 2) | (b0 >> 4)

	rh := (0x3E & uint32(code>>0x21)) |
		(0x01 & uint32(code>>0x20))
	rh = (rh << 2) | (rh >> 4)
	gh := (0x7F & uint32(code>>0x19))
	gh = (gh << 1) | (gh >> 6)
	bh := (0x3F & uint32(code>>0x13))
	bh = (bh << 2) | (bh >> 4)

	rv := (0x3F & uint32(code>>0x0D))
	rv = (rv << 2) | (rv >> 4)
	gv := (0x7F & uint32(code>>0x06))
	gv = (gv << 1) | (gv >> 6)
	bv := (0x3F & uint32(code>>0x00))
	bv = (bv << 2) | (bv >> 4)

	rh -= r0
	gh -= g0
	bh -= b0

	rv -= r0
	gv -= g0
	bv -= b0

	r0 *= 4
	g0 *= 4
	b0 *= 4

	for i := range 16 {
		x := uint32(i & 3)
		y := uint32(i >> 2)

		bp := ((x * bh) + (y * bv)) + b0
		gp := ((x * gh) + (y * gv)) + g0
		rp := ((x * rh) + (y * rv)) + r0

		offset := i * 4
		work[offset+0] = clamp[((rp+2)/4)&1023]
		work[offset+1] = clamp[((gp+2)/4)&1023]
		work[offset+2] = clamp[((bp+2)/4)&1023]
		work[offset+3] = 0xFF
	}
}

func decodeAlpha(work *[64]byte, code uint64) {
	base := int32(code >> 56)

	multiplier := int32((code >> 52) & 0x0F)
	which := int((code >> 48) & 0x0F)

	for i := range 16 {
		x := uint32(i & 3)
		y := uint32(i >> 2)

		shift := (((x ^ 3) * 4) | (y ^ 3)) * 3
		index := (code >> shift) & 7
		delta := multiplier * int32(alphaModifiers[which][index])

		work[(4*i)+3] = clamp[(base+delta)&1023]
	}
}

func decode11u(work *[64]byte, workOffset int, code uint64) {
	base := (8 * int32(code>>56)) + 4

	multiplier := max(1, 8*int32((code>>52)&0x0F))
	which := int((code >> 48) & 0x0F)

	for i := range 16 {
		x := uint32(i & 3)
		y := uint32(i >> 2)

		shift := (((x ^ 3) * 4) | (y ^ 3)) * 3
		index := (code >> shift) & 7
		delta := multiplier * int32(alphaModifiers[which][index])

		value11 := uint32(max(0, min(2047, base+delta)))
		value16 := (value11 << 5) | (value11 >> 6)

		work[workOffset+(2*i)+0] = uint8(value16 >> 8)
		work[workOffset+(2*i)+1] = uint8(value16 >> 0)
	}
}

func decode11s(work *[64]byte, workOffset int, code uint64) {
	base := 8 * max(int32(int8(code>>56)), -127)

	multiplier := max(1, 8*int32((code>>52)&0x0F))
	which := int((code >> 48) & 0x0F)

	for i := range 16 {
		x := uint32(i & 3)
		y := uint32(i >> 2)

		shift := (((x ^ 3) * 4) | (y ^ 3)) * 3
		index := (code >> shift) & 7
		delta := multiplier * int32(alphaModifiers[which][index])

		value11 := int32(max(-1023, min(1023, base+delta)))
		value16 := int32(0)
		if value11 >= 0 {
			value16 = (value11 << 5) | (value11 >> 5)
		} else {
			value11 = -value11
			value16 = (value11 << 5) | (value11 >> 5)
			value16 = -value16
		}
		value16 += 0x8000

		work[workOffset+(2*i)+0] = uint8(value16 >> 8)
		work[workOffset+(2*i)+1] = uint8(value16 >> 0)
	}
}

func weaveRG11(dst []byte, dstStride int, work *[64]byte) {
	for i := range 16 {
		x := i & 3
		y := i >> 2

		d := (dstStride * y) + (8 * x)
		rgba := dst[d : d+8]
		rgba[0] = work[(2*i)+0x00]
		rgba[1] = work[(2*i)+0x01]
		rgba[2] = work[(2*i)+0x20]
		rgba[3] = work[(2*i)+0x21]
		rgba[4] = 0x00
		rgba[5] = 0x00
		rgba[6] = 0xFF
		rgba[7] = 0xFF
	}
}

var diffs = [8]uint32{
	0x0000_0000, 0x0000_0001, 0x0000_0002, 0x0000_0003,
	0xFFFF_FFFC, 0xFFFF_FFFD, 0xFFFF_FFFE, 0xFFFF_FFFF,
}

var modifiers = [16][4]uint32{
	{0x0000_0002, 0x0000_0008, 0xFFFF_FFFE, 0xFFFF_FFF8}, // {  -8,  -2,  +2,   +8} re-ordered.
	{0x0000_0005, 0x0000_0011, 0xFFFF_FFFB, 0xFFFF_FFEF}, // { -17,  -5,  +5,  +17} re-ordered.
	{0x0000_0009, 0x0000_001D, 0xFFFF_FFF7, 0xFFFF_FFE3}, // { -29,  -9,  +9,  +29} re-ordered.
	{0x0000_000D, 0x0000_002A, 0xFFFF_FFF3, 0xFFFF_FFD6}, // { -42, -13, +13,  +42} re-ordered.
	{0x0000_0012, 0x0000_003C, 0xFFFF_FFEE, 0xFFFF_FFC4}, // { -60, -18, +18,  +60} re-ordered.
	{0x0000_0018, 0x0000_0050, 0xFFFF_FFE8, 0xFFFF_FFB0}, // { -80, -24, +24,  +80} re-ordered.
	{0x0000_0021, 0x0000_006A, 0xFFFF_FFDF, 0xFFFF_FF96}, // {-106, -33, +33, +106} re-ordered.
	{0x0000_002F, 0x0000_00B7, 0xFFFF_FFD1, 0xFFFF_FF49}, // {-183, -47, +47, +183} re-ordered.

	{0x0000_0000, 0x0000_0008, 0x0000_0000, 0xFFFF_FFF8}, // {  -8,   0,   0,   +8} re-ordered.
	{0x0000_0000, 0x0000_0011, 0x0000_0000, 0xFFFF_FFEF}, // { -17,   0,   0,  +17} re-ordered.
	{0x0000_0000, 0x0000_001D, 0x0000_0000, 0xFFFF_FFE3}, // { -29,   0,   0,  +29} re-ordered.
	{0x0000_0000, 0x0000_002A, 0x0000_0000, 0xFFFF_FFD6}, // { -42,   0,   0,  +42} re-ordered.
	{0x0000_0000, 0x0000_003C, 0x0000_0000, 0xFFFF_FFC4}, // { -60,   0,   0,  +60} re-ordered.
	{0x0000_0000, 0x0000_0050, 0x0000_0000, 0xFFFF_FFB0}, // { -80,   0,   0,  +80} re-ordered.
	{0x0000_0000, 0x0000_006A, 0x0000_0000, 0xFFFF_FF96}, // {-106,   0,   0, +106} re-ordered.
	{0x0000_0000, 0x0000_00B7, 0x0000_0000, 0xFFFF_FF49}, // {-183,   0,   0, +183} re-ordered.
}

var thModifiers = [8]uint8{
	3, 6, 11, 16, 23, 32, 41, 64,
}

var alphaModifiers = [16][8]int8{
	{-3, -6, -9, -15, +2, +5, +8, +14},
	{-3, -7, -10, -13, +2, +6, +9, +12},
	{-2, -5, -8, -13, +1, +4, +7, +12},
	{-2, -4, -6, -13, +1, +3, +5, +12},
	{-3, -6, -8, -12, +2, +5, +7, +11},
	{-3, -7, -9, -11, +2, +6, +8, +10},
	{-4, -7, -8, -11, +3, +6, +7, +10},
	{-3, -5, -8, -11, +2, +4, +7, +10},
	{-2, -6, -8, -10, +1, +5, +7, +9},
	{-2, -5, -8, -10, +1, +4, +7, +9},
	{-2, -4, -8, -10, +1, +3, +7, +9},
	{-2, -5, -7, -10, +1, +4, +6, +9},
	{-3, -4, -7, -10, +2, +3, +6, +9},
	{-1, -2, -3, -10, +0, +1, +2, +9},
	{-4, -6, -8, -9, +3, +5, +7, +8},
	{-3, -5, -7, -9, +2, +4, +6, +8},
}

var clamp = [1024]uint8{
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,

	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}
